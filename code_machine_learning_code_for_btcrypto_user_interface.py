# -*- coding: utf-8 -*-
"""Code: Machine Learning Code for BTCrypto User Interface

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f6PUnRn1FXMU8Ui8LWpw2WzM3DXdmFxA
"""

###Machine Learning Code for BTCrypto User Interface

##Importing libraries

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import datetime as datetime
import plotly.express as px

import time

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras import activations
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
from tensorflow.keras import optimizers
from sklearn import preprocessing
from joblib import dump, load

np.random.seed(7)

##Getting real-time data

#READ DATA
df = pd.read_csv('https://www.cryptodatadownload.com/cdd/Binance_BTCUSDT_d.csv', index_col=None
df.reset_index(inplace = True)
df.rename(columns=df.iloc[0], inplace = True)
df.drop(df.index[0], inplace=True)
df.reset_index(drop=True, inplace = True)
                 
df = df.astype({"unix": float})
df = df.astype({"open": float})
df = df.astype({"high": float})
df = df.astype({"low": float})
df = df.astype({"close": float})
df = df.astype({"Volume BTC": float})
df = df.astype({"Volume USDT": float})
df = df.astype({"tradecount": float})

print(df.dtypes)
print("\n*** DF ***")
df_copy = df.copy()

#CLEAN DATA TIMESTAMP

def change_timestamp (ts):
    digit_count = len(str(ts))
    if digit_count == 12:
        return (datetime.datetime.utcfromtimestamp(ts)).strftime('%Y-%m-%d %H:%M:%S')
    else:
        return (datetime.datetime.utcfromtimestamp(ts/1000)).strftime('%Y-%m-%d %H:%M:%S')

df_copy['unix_count'] = df.unix.apply(lambda x: len(str(x)))        
df_copy['dt_correct'] = df.unix.apply(lambda x: change_timestamp(x))
df_copy['dt'] = pd.to_datetime(df_copy.dt_correct.values)
df_copy['week_day'] = df_copy.dt.apply(lambda x: x.weekday())
df_copy.sort_values(by=['unix'],ascending=[True],inplace=True)

df_work = df_copy[['dt','week_day','close','Volume BTC']]

##Data Splitting and Data normalization

#SPLIT DATA INTO TEST AND TRAIN
X = df_work[['week_day','Volume BTC','close']]
Y = df_work[['close']]

#NORMALIZATION
f_transformer = preprocessing.MinMaxScaler((-1,1))
f_transformer = f_transformer.fit(X)

cnt_transformer = preprocessing.MinMaxScaler((-1,1))
cnt_transformer = cnt_transformer.fit(Y)

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, shuffle = False)

X_train_trans = f_transformer.transform(X_train)
X_test_trans = f_transformer.transform(X_test)

y_train_trans = cnt_transformer.transform(y_train)
y_test_trans = cnt_transformer.transform(y_test)
                 
#CREATE LAGGING DATASET FOR TIME-SERIES
def create_dataset(X, y, time_steps=1):
    Xs, ys = [], []
    for i in range(len(X) - time_steps):
        v = X[i:(i + time_steps)]
        Xs.append(v)
        ys.append(y[i + time_steps])
    return np.array(Xs), np.array(ys)

time_steps = 1
# reshape to [samples, time_steps, n_features]
X_train_f, y_train_f = create_dataset(X_train_trans, y_train_trans, time_steps)
X_test_f, y_test_f = create_dataset(X_test_trans, y_test_trans, time_steps)

##Building Bidirectional LSTM Model

seq_size = 183

model = keras.Sequential()
model.add(keras.Input(shape=((X_train_f.shape[1], X_train_f.shape[2]))))
model.add(layers.Bidirectional(layers.LSTM(300, activation = 'tanh', return_sequences=True)))
model.add(layers.LSTM(300, return_sequences=True, activation = 'tanh'))
model.add(layers.LSTM(300, return_sequences=True, activation = 'tanh'))
model.add(layers.LSTM(300, return_sequences=False, activation = 'tanh'))
model.add(layers.BatchNormalization())
model.add(layers.Flatten())
model.add(keras.layers.Dense(units=1))
model.compile(loss='mean_squared_error', optimizer='adam')
model.summary()

hist = model.fit(X_train_f[-seq_size:], y_train_f[-seq_size:], batch_size = 50, epochs = 25, shuffle=False, validation_split=0.1)

##Forecast

#Getting predicted future values

X_trans = f_transformer.transform(X)
y_trans = cnt_transformer.transform(Y)

X_f, y_f = create_dataset(X_trans, y_trans, time_steps)

prediction = [] #Empty list to populate later with predictions
future = 7 #Number of days to predict

#forecast
prediction = np.empty(7) #Empty list to populate later with predictions
 #Take last 7 days
#current_batch = current_batch.reshape(1, 24*seq_size, n_features) #Reshape
      
## Predict future, beyond test dates
future = 7 #Days

current_batch = X_f[-seq_size:]
current_pred = model.predict(current_batch)

rescaled_prediction = pd.DataFrame(cnt_transformer.inverse_transform(current_pred))
rescaled_prediction.columns = ['Price']

next_week_prices = rescaled_prediction.iloc[:7]

##Plot

#Get dates for plot x-axis

future=183

#Get dates
time = pd.to_datetime(df_work['dt'])

#Add new dates for the forecast period
time_series_array = []

for i in range(0, future+1):
    time_series_array.append(pd.Series(time.dt.date.iloc[-1]+ pd.DateOffset(i)))

time=pd.DataFrame(time_series_array)
time=time.rename(columns={0:'date'})

past_dates = pd.Series(df_work['dt'].tail(future))

past_week_dates = df_work['dt'].tail(7)
past_week_dates.reset_index(drop=True, inplace=True)
past_week_dates.columns = ['Date']

past_dates.reset_index(drop=True, inplace=True)
past_dates = past_dates.iloc[0:(future-1)]

future_dates = pd.Series(time['date']).tail(future+1)

plot_dates = pd.concat([past_dates, future_dates], axis=0)

#Plotting predictions for the next 6 months

historical = pd.DataFrame(data = df_work['close'].tail(183))
historical.columns = ['Price']
historical = historical.iloc[0:(future-1)]

type1 = []
for i in range(future):
  type1.append('Historical')
type1 = pd.DataFrame(type1, columns = ['Type'])

historical.reset_index(drop=True, inplace=True)
historical = pd.concat([historical,type1], axis=1)

type2 = []
for i in range(future):
  type2.append('Predicted')
type2 = pd.DataFrame(type2, columns = ['Type'])

rescaled_prediction = pd.DataFrame(cnt_transformer.inverse_transform(current_pred))
rescaled_prediction.columns = ['Price']

current_price = pd.DataFrame(data = df_work['close'].tail(1))
current_price.reset_index(drop=True, inplace=True)
current_price.columns= ['Price']

rescaled_prediction = pd.concat([current_price,rescaled_prediction], axis=0)
rescaled_prediction_df = pd.concat([rescaled_prediction,type2], axis=1)
                 
prices = pd.DataFrame()
prices = pd.concat([historical, rescaled_prediction_df], axis=0)

plot_dates = pd.DataFrame(plot_dates)
plot_dates.reset_index(drop=True, inplace=True)
plot_dates.columns = ['Date']

plotdf = pd.DataFrame()

plot_dates.reset_index(drop=True, inplace=True)
prices.reset_index(drop=True, inplace=True)

plotdf = pd.concat([plot_dates,prices], axis=1)
plotdf.reset_index(drop=True, inplace=True)
plotdf.set_index(['Date'], drop=True, inplace=True)

import seaborn as sns
sns.lineplot(x='Date', y='Price', hue='Type', data= plotdf)

fig = px.line(prices, x=plotdf.index.values, y="Price", color='Type', title='Bitcoin Price')
fig.show()

plotdf[:7].to_csv('prediction_machine_learning_next_7_days.csv')

plotdf.to_csv('prediction_machine_learning.csv')

#Plotting predictions for the next week

future=7

#Creating Historical Price Dataframe

h_week = pd.DataFrame(df_work['close'].tail(future))
h_week.columns = ['Price']

type1 = []
for i in range(future):
  type1.append('Historical')
type1 = pd.DataFrame(type1, columns = ['Type'])

h_week.reset_index(drop=True, inplace=True)
h_week = pd.concat([h_week,type1], axis=1)
h_week = pd.concat([past_week_dates,h_week,], axis=1)
h_week.set_index(['dt'], drop= True, inplace=True)

#Creating Predicted Price Dataframe

rescaled_week = pd.DataFrame(cnt_transformer.inverse_transform(current_pred)[:7])
rescaled_week.columns = ['Price']

current_price = pd.DataFrame(df_work['close'].tail(1))
current_price.columns = ['Price']
current_price.reset_index(drop=True, inplace=True)

rescaled_week = pd.concat([current_price,rescaled_week], axis=0)
rescaled_week.reset_index(drop=True, inplace=True)

type2 = []
for i in range(future+1):
  type2.append('Predicted')
type2 = pd.DataFrame(type2, columns = ['Type'])

p_week = pd.concat([rescaled_week,type2], axis=1)

next_week_dates = pd.DataFrame(future_dates.iloc[:7])
next_week_dates.columns = ['dt']

p_week = pd.concat([next_week_dates,p_week], axis=1)
p_week.set_index(['dt'], drop=True, inplace=True)

#Plot Price Dataframes

import matplotlib.pyplot as plt

# plot lines
plt.plot(h_week.index.values, h_week['Price'], label = "historical", color='green')
plt.plot(p_week.index.values, p_week['Price'], label = "predicted", color='orange')
plt.legend()
plt.xticks(rotation=45)
plt.show()
